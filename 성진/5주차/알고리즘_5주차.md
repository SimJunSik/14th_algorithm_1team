# 알고리즘 5주차
* BFS / DFS

오름차순 - 작은 값에서 큰 값으로<br>
내림차순 - 큰 값에서 작은 값으로

-----------------------------------

## Breadth-First Search (너비 우선 탐색)

참고<br>
https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html<br>

맹목적 탐색방법의 하나<br>
시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법<br>
즉, 깊게 탐색하기 전에 넓게 탐색<br>
방문하지 않은 정점이 없을 때까지 방문하지 않은 모든 정점들에 대해서도 너비 우선 검색을 적용<br>
큐를 사용해야 레벨 순서대로 접근이 가능<br>
어떤 노드를 방문했었는지 여부를 반드시 검사 해야 함<br>
'Prim', 'Dijkstra' 알고리즘과 유사<br>

## 장점
* 출발노드에서 목표노드까지의 최단 길이 경로를 보장

## 단점
* 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 함
* 해가 존재하지 않은 유한 그래프의 경우에는 모든 그래프를 탐색한 후에 실패로 끝남
* 무한 그래프의 경우에는 결코 해를 찾지도, 끝내지도 못함

![BFS](../images/BFS.gif)
<br>
By Blake Matheny - <span class="plainlinks"><a class="external text" href="//en.wikipedia.org">en.wikipedia</a></span>에서 공용으로 옮겨왔습니다., <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=1864649">링크</a>

```javascript

(function (global) {
    "use strict";

class Node {
    constructor(vertex) {
        this.vertex = vertex;
        this.adj = [];
        this.next = null;
        this.visit = false;
    }
    getVertex() {
        return this.vertex;
    }
    getAdj() {
        return this.adj;
    }
}

class Queue {
    //BFS 에 사용 될 큐
    constructor() {
        this.queue = [];
    }
    enqueue(data) {
        this.queue.push(data);
    }
    dequeue() {
        return this.queue.shift();
    }
    getValue() {
        return this.queue;
    }
}

class Graph {
    //양쪽 연결 그래프
    constructor(root) {
        this.root = root;
        let rootNode = new Node(0);
        this.root = rootNode;
    }

    getRoot() {
        return this.root;
    }

    insert(vertex, adj) {
        if (vertex === null || vertex === undefined || vertex === '' || adj === null || adj === undefined || adj === '' || vertex === adj) {
            console.log('invaild input!');
            //둘중 한개라도 없거나 둘다 같은 값일 경우
            return;
        }

        let checkNode = this.root;
        let input;
        let target;
        while(1) {

            if (checkNode.vertex === vertex) {
                input = checkNode;
            }

            if (checkNode.vertex === adj) {
                target = checkNode;
            }

            if (checkNode.next === null) {
                //넣을 때 양쪽을 한번에 넣는 방식
                if (input !== undefined && target !== undefined) {
                    let duplicateCheck = false;
                    input.adj.forEach(val => {
                        if (val.vertex === adj) duplicateCheck = true;
                    });

                    target.adj.forEach(val => {
                        if (val.vertex === vertex) duplicateCheck = true;
                    });

                    if (duplicateCheck) {
                        console.log('already connected');
                        break;
                    }

                    input.adj.push(target);
                    target.adj.push(input);
                } else if (input !== undefined && target === undefined) {
                    let node = new Node(adj);
                    checkNode.next = node;

                    node.adj.push(input);
                    input.adj.push(node);
                } else if (input === undefined && target !== undefined) {
                    let node = new Node(vertex);
                    checkNode.next = node;
                
                    node.adj.push(target);
                    target.adj.push(node);
                } else {
                    console.log('adj target is not exits');
                    //입력 된 노드 2개 모두 없을 경우
                }

                break;
            }

            checkNode = checkNode.next;
        }
        
    }

    BFS() {
        //BFS
        //처음 방문을 기준으로 큐에 넣음으로써 단방향을 가르킴
        let queue = new Queue();
        let checkNode = this.root;
        while(1) {
            checkNode.visit = false;
            if (checkNode.next === null) break;
            checkNode = checkNode.next;
        }

        queue.enqueue(this.root);
        this.root.visit = true;
        
        while(1) {
            let nowNode = queue.dequeue();
            
            nowNode.adj.forEach(val => {
                if (!val.visit) {
                    val.visit = true;
                    queue.enqueue(val);

                    console.log(`${nowNode.vertex} -> ${val.vertex}`);
                }
            });

            if (queue.getValue().length === 0) break;
        }
    }
}

let BFSgraph = new Graph();

}).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})

```

-----------------------------------

## DFS

<br>
<br>
<br>
<br>
<br>

![](../images/.gif)
<br>
<a href="javascript:;">링크</a> 

```javascript

(function (global) {
    "use strict";

    class Node {
        constructor() {
        }
        getValue() {
        }
    }

    class Graph {
        constructor(root) {
            this.root = root;
        }

        getRoot() {
            return this.root;
        }
    }
    
}).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})


```